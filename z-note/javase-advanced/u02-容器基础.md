# 1. 容器泛型

**概念：** 泛型的术语意思就是，适用于许多许多的类型，是JDK5引入的概念，实现了参数化类型的概念。
- 设计坐标类，可以操作int类型的坐标值。
- 升级坐标类，可以同时操作int类型，double类型和String类型的坐标。

**源码：** generic/PointTest.java

## 1.1 菱形语法

**概念：** 泛型声明格式也叫菱形语法，使用菱形语法可以不在坐标类中指定成员的具体类型，而是由外部调用者来决定和显示声明，这样的设计使得类的设计变得更加的灵活和简单。
- 泛型声明：
    - `class 类名<泛型, 泛型, ...>{ }`
    - 构造器名后面不能使用泛型，但是构造器参数可以。
    - 泛型不能使用基本数据类型。
- 泛型使用：
    - 标准写法：`类名<泛型> 实例 = new 类名<泛型>()`
    - 不建议写法：`类名<泛型> 实例 = new 类名()`
    - JDK8写法：`类名<泛型> 实例 = new 类名<>()`
    - 泛型擦除：`类名 实例 = new 类名()`：泛型擦除默认在容器内部将泛型向上转型为 `Object`。

**源码：** generic/PointWithGenericTypeTest.java

## 1.2 泛型检查

**概念：** javac会对程序的泛型进行运行前检查，若泛型使用错误会编译失败，以此来保证程序的健壮性和安全性，而JVM运行代码的时候会忽略掉所有泛型检查以提高运行效率，所以我们可以利用反射（运行时期的技术手段）来越过泛型检查。

**源码：** generic/SkipGenericTypeCheckTest.java

## 1.3 方法泛型

**概念：** 泛型除了定义在类上，也可以定义在方法上，方法上的泛型可以直接使用类上声明的泛型符号，也可以自己单独声明自定义的泛型符号，原则如下：
- 静态方法不可以直接使用类上的泛型，因为泛型只有在实例化的过程中才能被确定下来，
- 自定义的方法泛型必须在 `void` 或返回值类型之前使用菱形语法进行定义：
    - `public <V, K> K method(V t, K k){}`
    - `public static <Q> void method(Q q){}`

**源码：** generic/MethodGenericTypeTest.java

## 1.4 泛型限定

**概念：** 在方法的返回值或参数类型中，我们可以使用一些特殊的泛型声明格式来对入参的泛型进行限定。
- `<?>`：未知类型限定，支持一切泛型。
- `<? super Child>`：只接受Child和Child的父类。
- `<? extends Parent>`：只接受Parent和Parent的子类。

**源码：** generic/GenericTypeLimitTest.java

## 1.5 反射泛型

**概念：** `java.lang.reflect` 包中提供了一个参数化类型接口 `ParameterizedType`，它是类型接口 `Type` 的子接口，表示参数化类型（凡是带有泛型的参数类型都属于它的范畴）。
- `Method` 相关API方法：
    - `Type[] getGenericParameterTypes()`：获取方法的所有参数类型及其泛型类型，没有泛型的参数类型也会被获取到。
    - `Type getGenericReturnType()`：获取方法的返回值类型及其泛型类型。
- `Type` 相关API方法：
    - `String getTypeName()`：获取参数类型的类全名。
- `ParameterizedType` 相关API方法：
    - `Type[] getActualTypeArguments()`：获取泛型类型对应的真实java类型。

**源码：** generic/ReflectGenericTypeTest.java

# 2. 数据结构-链表

**概念：** 链表和数组都是存储数据的一种线性结构，链表就像一条锁链，锁链中的每一个铁环，就可以看做是链表的最基本单位：`Node` 节点。
- 链表不连续：在每次添加新元素到链表中的时候，链表的节点都是重新new出来的，即使数据类型一样，他们之间的内存地址也是没有规律，互相不连续的，所以链表中的查询操作需要从头节点开始遍历，效率比数组低。
- 链表不定长：在内存中，链表的节点数量是动态分配的，不固定，所以添加，插入，删除等操作对于链表来说，只需要创建新节点，然后改变几个相关的引用值，就可以完成，效率比数组高。

## 2.1 单向链表

**概念：** 在单链表中，我们只要知道了链表头节点的内存地址，就可以顺着之后每一个节点的next后继指针域一直寻找到尾节点，这就是链表的遍历过程，但是单链表的遍历，只能从头到尾，不能从尾到头，是单方向的。
- 单链表的节点一般分为两个部分：
    - data数据域：用来存储节点数据，如一个字符串、一个User对象等。
    - next后继指针域：用来保存下一个节点的内存地址，以串起整个链表结构。
- 单链表的尾节点的next指向null，在遍历链表时可以以此为遍历终止的条件。

**源码：** generic/SingleLinkedListTest.java

## 2.2 双向链表

**概念：** 双向链表在访问其中一个节点的时候，既能够向后找到下一个节点，又能向前找到上一个节点。
- 双链表的节点一般分为三个部分：
    - pre前驱指针域：用来保存上一个节点的内存地址。
    - data数据域：用来存储节点数据，如一个字符串、一个User对象等。
    - next后继指针域：用来保存下一个节点的内存地址。
- 双链表的尾节点的next指向null，在遍历链表时可以以此为遍历终止的条件。

**源码：** generic/DoubleLinkedListTest.java

## 2.3 循环链表

**概念：** 环链表就是首尾相连的单链表，即尾节点的next指向头节点，从而形成一个环。
- 循环表的分为两种：
    - 单循环链表：首尾相连的单链表。
    - 双循环链表：首尾相连的双链表。
- 循环链表的尾节点的next指向头节点，在遍历链表时可以以此为遍历终止的条件。

**源码：** generic/CycleLinkedListTest.java




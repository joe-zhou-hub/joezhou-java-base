# 1. 数学运算符

**概念：** 
- 基本运算：包括加（`+`），减（`-`），乘（`*`），除（`/`）。
    - 除法运算中，如果操作数都是整数，则结果也是整数。
- 取余运算：取余运算符（`%`），0取余任何数都等于0，正负号只和等号左边操作数的一致。
- 除零问题：任何数除以0都会抛异常，任何数除以0.0结果都为无穷大 `infinity`。

**源码：** /javase-start/
- src: `c.j.calculation.MathOperatorsTest.base()`

## 1.1 自运算

**概念：** 
- 自运算 `++` / `--` 即给自身加1或减1。
- 自运算优先级最高。
- 自运算只能用在变量上，常量没有自运算。
- 自运算分为先用后加(a++)和先加后用(++a);

**源码：** /javase-start/
- src: `c.j.calculation.MathOperatorsTest.self()`

## 1.2 数值溢出问题

**概念：** 
- 我们都知道变量是有自己的存值范围的，比如 byte 的存值范围是-128 ~ 127之间，那么假设在计算的时候发生了数值溢出，会产生物极必反的现象：
    - 最大值加1变成最小值
    - 最小值减1变成最大值
- 二进制计算的原理：将原码转成补码，使用补码进行计算，再将结果转回原码。
- 模拟 2147483647 + 1 的过程
    - 原码： [01111111 11111111 11111111 11111111]
    - 反码： [01111111 11111111 11111111 11111111]，与原码相同
    - 补码： [01111111 11111111 11111111 11111111]，与原码相同
    - 加一： [10000000 00000000 00000000 00000000]，计算会影响符号位，toBinaryString()方法会打印这个值
    - 反码： [11111111 11111111 11111111 11111111]，符号位不动，其余按位取反
    - 补码： [10000000 00000000 00000000 00000000]，反码 + 1，符号位不参与补码进位
    - 真值： -2147483648（int最小值）
- 模拟 -2147483648 - 1 的过程
    - 原码： [10000000 00000000 00000000 00000000]
    - 反码： [11111111 11111111 11111111 11111111]，符号位不动，其余按位取反
    - 补码： [10000000 00000000 00000000 00000000]，反码 + 1，符号位不参与补码进位
    - 减一： [01111111 11111111 11111111 11111111]，计算会影响符号位，toBinaryString()方法会打印这个值
    - 反码： [01111111 11111111 11111111 11111111]，与原码相同
    - 补码： [01111111 11111111 11111111 11111111]，与原码相同
    - 真值： 2147483647（int最大值）

**源码：** /javase-start/
- src: `c.j.calculation.MathOperatorsTest.numericalOverflow()`

# 2. 赋值运算符

**概念：** java中使用一个等号表示赋值，赋值要从后向前理解：
- `+=`：追加，`a += b` 就等价于 `a = a+b`，将 `a+b` 的结果重新赋值给 `a`
- `-=`：追减，`a -= b` 就等价于 `a = a-b`，将 `a-b` 的结果重新赋值给 `a`
- `*=`：追乘，`a *= b` 就等价于 `a = a*b`，将 `a*b` 的结果重新赋值给 `a`
- `/=`：追除，`a /= b` 就等价于 `a = a/b`，将 `a/b` 的结果重新赋值给 `a`
- `%=`：追取余，`a %= b` 就等价于 `a = a%b`，将 `a+b` 的结果重新赋值给 `a`

**源码：** /javase-start/
- src: `c.j.calculation.MathOperatorsTest.assignment()`

# 3. 比较运算符

**概念：** 比较运算一定会返回boolean类型的值，运算符包括：`==` / `>` / `<` / `>=` / `<=` / `!=`。

**源码：** /javase-start/
- src: `c.j.calculation.MathOperatorsTest.compare()`

# 4. 逻辑运算符

**概念：** 逻辑运算包括逻辑与(`&&`)，逻辑或(`||`)和逻辑非(`!`)。
- 口诀：与中有假(则假)，或中有真(则真)。
- 逻辑运算优先级：非 > 与 > 或。

**源码：** /javase-start/
- src: `c.j.calculation.MathOperatorsTest.logic()`

# 5. 位运算符

**概念：** 
- 位运算包括位与(`&`)，位或(`|`)和取反(`~`)。
- 逻辑运算会发生短路现象，而位运算不会。

## 5.1 短路现象

**概念：** 

**源码：** /javase-start/
- src: `c.j.calculation.MathOperatorsTest.shortCircuit()`

## 5.2 按位与

**流程：** 计算 4 & 6 的结果，二进制流程如下：
- 求4的原码：`00000000 00000000 00000000 00000100`
- 求4的反码：`00000000 00000000 00000000 00000100`，反码同原码
- 求4的补码：`00000000 00000000 00000000 00000100`，补码同原码
- 求6的原码：`00000000 00000000 00000000 00000110`
- 求6的反码：`00000000 00000000 00000000 00000110`，反码同原码
- 求6的补码：`00000000 00000000 00000000 00000110`，补码同原码
- 补码间位与计算：数字按位与运算中，有0则0：
	- 四的补码：`00000000 00000000 00000000 00000100`
	- 六的补码：`00000000 00000000 00000000 00000110`
	- 计算结果：`00000000 00000000 00000000 00000100`
- 将结算结果再次求补码以转回原码：
  - 对结果求反码：`00000000 00000000 00000000 00000100`，反码同原码
  - 对结果求补码：`00000000 00000000 00000000 00000100`，补码同原码
  - 求真值：4

**源码：** /javase-start/
- src: `c.j.calculation.MathOperatorsTest.andOfBit()`

## 5.3 按位或

**流程：** 计算 4 | 6 的结果，二进制流程如下：
- 求4的原码：`00000000 00000000 00000000 00000100`
- 求4的反码：`00000000 00000000 00000000 00000100`，反码同原码
- 求4的补码：`00000000 00000000 00000000 00000100`，补码同原码
- 求6的原码：`00000000 00000000 00000000 00000110`
- 求6的反码：`00000000 00000000 00000000 00000110`，反码同原码
- 求6的补码：`00000000 00000000 00000000 00000110`，补码同原码
- 补码间位或计算：数字按位与或算中，有1则1：
	- 四的补码：`00000000 00000000 00000000 00000100`
	- 六的补码：`00000000 00000000 00000000 00000110`
	- 计算结果：`00000000 00000000 00000000 00000110`
- 将结算结果再次求补码以转回原码：
  - 对结果求反码：`00000000 00000000 00000000 00000110`，反码同原码
  - 对结果求补码：`00000000 00000000 00000000 00000110`，补码同原码
  - 求真值：6

**源码：** /javase-start/
- src: `c.j.calculation.MathOperatorsTest.orOfBit()`

## 5.4 按位取反

**流程：** 计算 ~4 的结果，二进制流程如下：
- 求4的原码：`00000000 00000000 00000000 00000100`
- 求4的反码：`00000000 00000000 00000000 00000100`，反码同原码
- 求4的补码：`00000000 00000000 00000000 00000100`，补码同原码
- 补码按位取反计算：每一位都取反，包括符号位：
	- 四的补码：`00000000 00000000 00000000 00000100`
	- 计算结果：`11111111 11111111 11111111 11111011`
- 将结算结果再次求补码以转回原码：
	- 对结果求反码：`10000000 00000000 00000000 00000100`
	- 对结果求补码：`10000000 00000000 00000000 00000101`
	- 求真值：-5

**源码：** /javase-start/
- src: `c.j.calculation.MathOperatorsTest.notOfBit()`

## 5.5 按位异或

**概念：** 位置上相同为0，不同为1：
- 快捷算法：无进位相加。
- 异或操作满足交换律和结合律，即a^(b^c) 等同 (c^b)^z。
- 规律：N^0=N，N^N=0。

**流程：** 计算 4 ^ 6 的结果，二进制流程如下：
- 求4的原码：`00000000 00000000 00000000 00000100`
- 求4的反码：`00000000 00000000 00000000 00000100`，反码同原码
- 求4的补码：`00000000 00000000 00000000 00000100`，补码同原码
- 求6的原码：`00000000 00000000 00000000 00000110`
- 求6的反码：`00000000 00000000 00000000 00000110`，反码同原码
- 求6的补码：`00000000 00000000 00000000 00000110`，补码同原码
- 补码按位异或计算：相同为0，不同为1，包括符号位：
	- 四的补码：`00000000 00000000 00000000 00000100`
    - 六的补码：`00000000 00000000 00000000 00000110`
	- 计算结果：`00000000 00000000 00000000 00000010`
- 将结算结果再次求补码以转回原码：
	- 对结果求反码：`00000000 00000000 00000000 00000010`，反码同原码
	- 对结果求补码：`00000000 00000000 00000000 00000010`，补码同原码
	- 求真值：2

**源码：** /javase-start/
- src: `c.j.calculation.MathOperatorsTest.xorOfBit()`

## 5.6 左移动

**流程：** 计算 -2 << 3 的结果，二进制流程如下：
- 求-2的原码：`10000000 00000000 00000000 00000010`
- 求-2的反码：`11111111 11111111 11111111 11111101`
- 求-2的补码：`11111111 11111111 11111111 11111110`
- 补码左移动3个单位：溢出就溢出，右边用0补：
	- 负二补码：`11111111 11111111 11111111 11111110`
	- 计算结果：`11111111 11111111 11111111 11110000`
- 将结算结果再次求补码以转回原码：
  - 对结果求反码：`10000000 00000000 00000000 00001111`
  - 对结果求补码：`10000000 00000000 00000000 00010000`
  - 求真值：-16

**源码：** /javase-start/
- src: `c.j.calculation.MathOperatorsTest.leftMoveOfBit()`

> 左移动公式：N左移3次，相当于N乘以2的3次方。

## 5.7 右移动

**流程：** 计算 -2 >> 3 的结果，二进制流程如下：
- 求-2的原码：`10000000 00000000 00000000 00000010`
- 求-2的反码：`11111111 11111111 11111111 11111101`
- 求-2的补码：`11111111 11111111 11111111 11111110`
- 补码右移动3个单位：溢出就溢出，左边用符号位补：
	- 负二补码：`11111111 11111111 11111111 11111110`
	- 计算结果：`11111111 11111111 11111111 11111111`
- 将结算结果再次求补码以转回原码：
	- 对结果求反码：`10000000 00000000 00000000 00000000`
	- 对结果求补码：`10000000 00000000 00000000 00000001`
	- 求真值：-1

**源码：** /javase-start/
- src: `c.j.calculation.MathOperatorsTest.rightMoveOfBit()`

> 右移动公式：N右移3次，相当于N除以2的3次方。

## 5.8 无符号右移动

**流程：** 计算 -2 >>> 3 的结果，二进制流程如下：
- 求-2的原码：`10000000 00000000 00000000 00000010`
- 求-2的反码：`11111111 11111111 11111111 11111101`
- 求-2的补码：`11111111 11111111 11111111 11111110`
- 补码无符号右移动3个单位：溢出就溢出，左边用0补：
	- 负二补码：`11111111 11111111 11111111 11111110`
	- 计算结果：`00011111 11111111 11111111 11111111`
- 将结算结果再次求补码以转回原码：
	- 对结果求反码：`00011111 11111111 11111111 11111111`，反码同原码
	- 对结果求补码：`00011111 11111111 11111111 11111111`，补码同原码
	- 求真值：536870911

**源码：** /javase-start/
- src: `c.j.calculation.MathOperatorsTest.noSignRightMoveOfBit()`

# 6. 三元运算符

**概念：** 三目运算符，也叫三部运算符，也叫三元运算符。
- 公式：`X ? Y : Z`，其中X为布尔类型表达式，当X的结果为true时返回Y，否则返回Z。
- Y和Z的返回值类型必须一致。
- 三目运算符一定要接它的返回值，它的返回值类型就是你Y和Z的返回值类型。

**源码：** /javase-start/
- src: `c.j.calculation.MathOperatorsTest.ternary()`

# 7. Math工具类

**概念：** `java.lang.Math` 工具类提供了大量用于数学运算的方法，Math类是final类，因此不能从Math类继承，Math类中的方法都是static方法，因此不必创建Math类的对象就可以直接使用类的方法。
- `Math.abs(-10)`：绝对值。
- `Math.sqrt(16)`：平方根。
- `Math.cbrt(8)`：立方根。
- `Math.ceil(2.1)`：向上取整。
- `Math.floor(2.9)`：向下取整。
- `Math.max(1, 6)`：最大值。
- `Math.min(1, 6)`：最小值。
- `Math.pow(2, 3)`：a的b次幂。
- `Math.round(2.4)`：四舍五入。
- `Math.random()`：随机数：每次随机都生成一个[0-1)之间的数字。

> 随机数生成的代码，更建议使用 `new Random().nextInt(5);`，此时可以直接随机生成一个0到5范围内的int值。

**源码：** /javase-start/
- src: `c.j.calculation.MathOperatorsTest.mathApi()`